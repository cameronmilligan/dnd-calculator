<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Encounter Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #121212;
            color: #E0E0E0;
        }
        .container {
            max-width: 1024px;
            margin: auto;
            padding: 1rem;
        }
        .card {
            background-color: #1E1E1E;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        input, select {
            background-color: #2D2D2D;
            border: 1px solid #444;
            color: #E0E0E0;
            border-radius: 0.5rem;
            padding: 0.5rem;
        }
        .btn-primary {
            background-color: #6200EE;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s;
        }
        .btn-primary:hover {
            background-color: #3700B3;
        }
        .table-container {
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }
        th, td {
            padding: 0.75rem;
            border-bottom: 1px solid #333;
            text-align: left;
        }
        th {
            background-color: #2D2D2D;
            font-weight: 600;
            color: #BB86FC;
        }
        tr:hover {
            background-color: #2A2A2A;
        }
        .section-header {
            font-size: 1.5rem;
            font-weight: bold;
            color: #BB86FC;
            margin-bottom: 1rem;
            border-bottom: 2px solid #3700B3;
            padding-bottom: 0.5rem;
        }
        .damage-input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .damage-input-group input {
            width: 80px;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #BB86FC;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="p-4">

<div class="container space-y-8">
    <header class="text-center py-8">
        <h1 class="text-4xl font-bold text-white">D&D Encounter Calculator</h1>
        <p class="text-gray-400 mt-2">Create your party and test them against monsters.</p>
    </header>

    <!-- Party Roster Section -->
    <div class="card space-y-4">
        <div class="section-header">Party Roster</div>
        <div id="character-list" class="space-y-4"></div>
        <button id="add-character-btn" class="btn-primary w-full md:w-auto">Add New Character</button>
    </div>

    <!-- Encounter Setup Section -->
    <div class="card space-y-4">
        <div class="section-header">Encounter Setup</div>
        <div class="flex flex-col md:flex-row items-center gap-4 mb-4">
            <input type="text" id="monster-prompt" placeholder="e.g., A corrupted fey knight or A chaotic elemental" class="flex-grow w-full">
            <button id="generate-monster-btn" class="btn-primary flex items-center justify-center gap-2 w-full md:w-auto">
                <span id="generate-text">Generate ✨Monster</span>
                <div id="loading-spinner" class="loading-spinner hidden"></div>
            </button>
        </div>
        <div id="monster-list" class="space-y-4"></div>
        <button id="add-monster-btn" class="btn-primary w-full md:w-auto">Add New Monster</button>
    </div>

    <!-- Results Section -->
    <div class="card space-y-4">
        <div class="section-header">Encounter Analysis</div>
        <div id="results" class="space-y-4">
            <div id="encounter-summary" class="bg-purple-900/30 p-4 rounded-lg">
                <p class="text-lg font-semibold mb-2">Encounter Summary</p>
                <div class="text-gray-300 grid md:grid-cols-2 gap-4">
                    <div>
                        <p class="font-bold text-white">Party's E-DPR:</p>
                        <p>Total: <span id="total-party-edpr" class="font-bold text-white">0</span></p>
                        <p>Volatility (Rounds): <span id="party-volatility" class="font-bold text-white">0</span></p>
                        <p>Average Party HP: <span id="average-party-hp" class="font-bold text-white">0</span></p>
                    </div>
                    <div>
                        <p class="font-bold text-white">Enemies' E-DPR:</p>
                        <p>Total: <span id="total-enemy-edpr" class="font-bold text-white">0</span></p>
                        <p>Volatility (Rounds): <span id="enemy-volatility" class="font-bold text-white">0</span></p>
                        <p>Average Player HP Drained: <span id="avg-hp-drained" class="font-bold text-white">0%</span> per round</p>
                    </div>
                </div>
            </div>
            
            <div id="individual-results" class="table-container">
                <p class="text-lg font-semibold mb-2">Party Performance vs. <span id="monster-name-display" class="text-white">Monster</span></p>
                <table id="results-table">
                    <thead>
                        <tr>
                            <th>Character</th>
                            <th>AC</th>
                            <th>+ to Hit</th>
                            <th>Hit Chance</th>
                            <th>Avg Damage</th>
                            <th>E-DPR</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>

            <div id="monster-results" class="table-container">
                <p class="text-lg font-semibold mb-2">Monster Performance vs. Party</p>
                <table id="monster-results-table">
                    <thead>
                        <tr>
                            <th>Monster</th>
                            <th>AC</th>
                            <th>+ to Hit</th>
                            <th>Hit Chance</th>
                            <th>Avg Damage</th>
                            <th>E-DPR</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
            <div id="tactical-notes" class="bg-gray-800 p-4 rounded-lg hidden">
                <p class="text-lg font-semibold text-purple-300">Tactical Notes</p>
                <p id="tactical-content" class="text-gray-300 mt-2"></p>
            </div>
        </div>
    </div>
</div>

<script>
    // --- Gemini API Integration ---
    async function generateMonster() {
        const prompt = document.getElementById('monster-prompt').value;
        const button = document.getElementById('generate-monster-btn');
        const spinner = document.getElementById('loading-spinner');
        const buttonText = document.getElementById('generate-text');

        if (!prompt) {
            alert('Please enter a description for the monster!');
            return;
        }

        // Show loading state
        button.disabled = true;
        spinner.classList.remove('hidden');
        buttonText.textContent = 'Generating...';

        const systemPrompt = `You are a Dungeons & Dragons 5e monster generator. Your task is to create a monster stat block and tactical advice in a single, valid JSON object. The JSON should have the following fields: "name" (string), "ac" (integer), "hp" (integer), "toHit" (integer), "attacks" (an array of objects, where each object has "damage" (string, e.g., "1d8+5") and "count" (integer)), and "tactics" (string, providing DM advice on how to play the monster). Do not include any other text or markdown outside of the JSON object. The monster should be appropriate for a party of 5th-level adventurers. Base your response on standard D&D 5e monster rules.`;
        const userQuery = `Generate a D&D 5e monster based on the following description: ${prompt}`;

        const payload = {
            contents: [{ parts: [{ text: userQuery }] }],
            systemInstruction: {
                parts: [{ text: systemPrompt }]
            },
            generationConfig: {
                responseMimeType: "application/json",
            },
        };

        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

        let success = false;
        let retries = 0;
        const maxRetries = 3;
        const baseDelay = 1000;

        while (!success && retries < maxRetries) {
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    const result = await response.json();
                    const jsonString = result.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (jsonString) {
                        const newMonster = JSON.parse(jsonString);
                        addMonsterRow(newMonster);
                        document.getElementById('tactical-content').textContent = newMonster.tactics;
                        document.getElementById('tactical-notes').classList.remove('hidden');
                        saveToLocalStorage();
                        updateCalculations();
                        success = true;
                    } else {
                        throw new Error('No JSON content found in response.');
                    }
                } else {
                    throw new Error(`API request failed with status: ${response.status}`);
                }
            } catch (error) {
                console.error("Error generating monster:", error);
                retries++;
                if (retries < maxRetries) {
                    const delay = baseDelay * (2 ** retries);
                    console.log(`Retrying in ${delay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                } else {
                    document.getElementById('tactical-content').textContent = "Failed to generate monster. Please try again with a different prompt.";
                    document.getElementById('tactical-notes').classList.remove('hidden');
                }
            }
        }

        // Reset loading state
        button.disabled = false;
        spinner.classList.add('hidden');
        buttonText.textContent = 'Generate ✨Monster';
    }


    // Helper function to parse a dice string like "1d8+5" or "2d6"
    function getDamageRange(damageString) {
        if (!damageString) return { min: 0, avg: 0, max: 0 };
        
        let minDamage = 0;
        let avgDamage = 0;
        let maxDamage = 0;

        const parts = damageString.split('+');
        const dicePart = parts[0];
        const bonus = parts.length > 1 ? parseInt(parts[1]) : 0;
        
        if (dicePart.includes('d')) {
            const [numStr, sidesStr] = dicePart.split('d');
            const num = numStr ? parseInt(numStr) : 1;
            const sides = parseInt(sidesStr);
            
            minDamage = num * 1;
            avgDamage = num * ((sides + 1) / 2);
            maxDamage = num * sides;
        } else {
            minDamage = parseInt(dicePart);
            avgDamage = parseInt(dicePart);
            maxDamage = parseInt(dicePart);
        }
        return { min: minDamage + bonus, avg: avgDamage + bonus, max: maxDamage + bonus };
    }

    // Function to calculate hit percentage based on +hit and AC
    function getHitChance(toHit, ac) {
        const rollNeeded = Math.max(2, ac - toHit);
        let probability = (21 - rollNeeded) / 20;
        probability = Math.max(0.05, Math.min(0.95, probability));
        return probability;
    }

    // Main function to run all calculations and update the UI
    function updateCalculations() {
        const monsters = getMonsters();
        const characters = getCharacters();
        
        // --- Calculate Party Performance ---
        let totalPartyEDPR = 0;
        let totalPartyHP = 0;
        let minPartyDPR = 0;
        let maxPartyDPR = 0;

        const monsterTableBody = document.querySelector('#monster-results-table tbody');
        monsterTableBody.innerHTML = '';
        
        // --- Calculate Monster Performance ---
        let totalEnemyEDPR = 0;
        let minEnemyDPR = 0;
        let maxEnemyDPR = 0;

        monsters.forEach(monster => {
            let enemyAvgDamagePerTurn = 0;
            let enemyExpectedDamagePerRound = 0;
            let enemyMinDPR = 0;
            let enemyMaxDPR = 0;

            const targetAC = characters.length > 0 ? (characters.reduce((sum, char) => sum + char.ac, 0) / characters.length) : 15;
            const hitChance = getHitChance(monster.toHit, targetAC);

            if (monster.attacks) {
                monster.attacks.forEach(attack => {
                    const damageRange = getDamageRange(attack.damage);
                    enemyAvgDamagePerTurn += damageRange.avg * attack.count;
                    enemyExpectedDamagePerRound += (hitChance * damageRange.avg * attack.count);
                    enemyMinDPR += (hitChance * damageRange.min * attack.count);
                    enemyMaxDPR += (hitChance * damageRange.max * attack.count);
                });
            }

            totalEnemyEDPR += enemyExpectedDamagePerRound;
            minEnemyDPR += enemyMinDPR;
            maxEnemyDPR += enemyMaxDPR;

            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${monster.name}</td>
                <td>${monster.ac}</td>
                <td>${monster.toHit}</td>
                <td>${(hitChance * 100).toFixed(0)}%</td>
                <td>${enemyAvgDamagePerTurn.toFixed(2)}</td>
                <td>${enemyExpectedDamagePerRound.toFixed(2)}</td>
            `;
            monsterTableBody.appendChild(row);
        });

        // --- Calculate Party Performance ---
        const resultsBody = document.querySelector('#results-table tbody');
        resultsBody.innerHTML = '';
        
        const monster = monsters[0] || { ac: 15, hp: 1, name: 'No Monster' };
        document.getElementById('monster-name-display').textContent = monster.name;
        
        characters.forEach(char => {
            totalPartyHP += char.hp;
            
            const hitChance = getHitChance(char.toHit, monster.ac);
            let avgDamagePerTurn = 0;
            let expectedDamagePerRound = 0;
            let charMinDPR = 0;
            let charMaxDPR = 0;

            if (char.attacks) {
                char.attacks.forEach(attack => {
                    const damageRange = getDamageRange(attack.damage);
                    avgDamagePerTurn += damageRange.avg * attack.count;
                    
                    if (attack.isSneakAttack) {
                        expectedDamagePerRound += (hitChance * damageRange.avg);
                        charMinDPR += (hitChance * damageRange.min);
                        charMaxDPR += (hitChance * damageRange.max);
                    } else {
                        expectedDamagePerRound += (hitChance * damageRange.avg * attack.count);
                        charMinDPR += (hitChance * damageRange.min * attack.count);
                        charMaxDPR += (hitChance * damageRange.max * attack.count);
                    }
                });
            } else if (char.flatDamage) {
                avgDamagePerTurn = char.flatDamage;
                expectedDamagePerRound = char.flatDamage;
                charMinDPR = char.flatDamage;
                charMaxDPR = char.flatDamage;
            }

            totalPartyEDPR += expectedDamagePerRound;
            minPartyDPR += charMinDPR;
            maxPartyDPR += charMaxDPR;

            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${char.name}</td>
                <td>${char.ac}</td>
                <td>${char.toHit}</td>
                <td>${(hitChance * 100).toFixed(0)}%</td>
                <td>${avgDamagePerTurn.toFixed(2)}</td>
                <td>${expectedDamagePerRound.toFixed(2)}</td>
            `;
            resultsBody.appendChild(row);
        });

        // --- Update Summary ---
        const averagePartyHP = characters.length > 0 ? (totalPartyHP / characters.length).toFixed(1) : 0;
        const roundsToDefeatMonster = totalPartyEDPR > 0 ? (monster.hp / totalPartyEDPR).toFixed(1) : 0;
        const roundsToDefeatParty = totalEnemyEDPR > 0 ? (totalPartyHP / totalEnemyEDPR).toFixed(1) : 0;
        const avgHpDrained = totalEnemyEDPR > 0 && characters.length > 0 && averagePartyHP > 0 ? ((totalEnemyEDPR / characters.length) / averagePartyHP * 100).toFixed(1) : 0;
        
        const monsterRoundsLow = maxPartyDPR > 0 ? (monster.hp / maxPartyDPR).toFixed(1) : 0;
        const monsterRoundsHigh = minPartyDPR > 0 ? (monster.hp / minPartyDPR).toFixed(1) : 0;
        
        const partyRoundsLow = maxEnemyDPR > 0 ? (totalPartyHP / maxEnemyDPR).toFixed(1) : 0;
        const partyRoundsHigh = minEnemyDPR > 0 ? (totalPartyHP / minEnemyDPR).toFixed(1) : 0;

        document.getElementById('total-party-edpr').textContent = totalPartyEDPR.toFixed(2);
        document.getElementById('party-volatility').textContent = `${monsterRoundsLow} - ${monsterRoundsHigh} rounds`;
        document.getElementById('average-party-hp').textContent = averagePartyHP;

        document.getElementById('total-enemy-edpr').textContent = totalEnemyEDPR.toFixed(2);
        document.getElementById('enemy-volatility').textContent = `${partyRoundsLow} - ${partyRoundsHigh} rounds`;
        document.getElementById('avg-hp-drained').textContent = `${avgHpDrained}%`;
    }

    // --- Data Management Functions ---
    const characterList = document.getElementById('character-list');
    const monsterList = document.getElementById('monster-list');

    function saveToLocalStorage() {
        const characters = getCharacters();
        const monsters = getMonsters();
        localStorage.setItem('dnd_calculator_characters', JSON.stringify(characters));
        localStorage.setItem('dnd_calculator_monsters', JSON.stringify(monsters));
    }

    function loadFromLocalStorage() {
        const characters = JSON.parse(localStorage.getItem('dnd_calculator_characters')) || getDefaultCharacters();
        const monsters = JSON.parse(localStorage.getItem('dnd_calculator_monsters')) || getDefaultMonsters();
        
        characters.forEach(addCharacterRow);
        monsters.forEach(addMonsterRow);
        
        updateCalculations();
    }
    
    function getDefaultCharacters() {
        return [
            { name: 'Fletcher', hp: 39, toHit: 7, ac: 16, attacks: [{ damage: '1d8+5', count: 1 }, { damage: '2d6', count: 1, isSneakAttack: true }] },
            { name: 'Lucien', hp: 54, toHit: 6, ac: 16, attacks: [{ damage: '1d6+7', count: 1 }, { damage: '1d6+7', count: 1 }] },
            { name: 'Ronlim', hp: 49, toHit: 7, ac: 16, attacks: [{ damage: '2d6+4', count: 2 }] },
            { name: 'Niles', hp: 38, toHit: 8, ac: 17, attacks: [{ damage: '1d8+5', count: 1 }, { damage: '1d8+5', count: 2 }] },
            { name: 'Pedro', hp: 54, toHit: 6, ac: 18, attacks: [{ damage: '1d8+3', count: 2 }] },
            { name: 'Inquiry', hp: 38, toHit: 7, ac: 16, flatDamage: 20 },
            { name: 'Zed', hp: 38, toHit: 7, ac: 18, attacks: [{ damage: '1d8', count: 1 }] }
        ];
    }

    function getDefaultMonsters() {
        return [
            { name: 'Death Cultist', ac: 17, hp: 136, toHit: 7, attacks: [{ damage: '1d10+4', count: 1 }, { damage: '2d10', count: 1 }] },
            { name: 'Cultist Fanatic', ac: 12, hp: 33, toHit: 4, attacks: [{ damage: '1d6+2', count: 1 }] },
            { name: 'Cultist Fanatic', ac: 12, hp: 33, toHit: 4, attacks: [{ damage: '1d6+2', count: 1 }] }
        ];
    }
    
    function getCharacters() {
        const characters = [];
        characterList.querySelectorAll('.character-row').forEach(row => {
            const name = row.querySelector('[data-name]').value;
            const toHit = parseInt(row.querySelector('[data-to-hit]').value) || 0;
            const ac = parseInt(row.querySelector('[data-ac]').value) || 0;
            const hp = parseInt(row.querySelector('[data-hp]').value) || 0;
            const damageInputs = Array.from(row.querySelectorAll('[data-damage]'));
            const isFlatDamage = row.querySelector('[data-flat-damage]').checked;
            
            if (isFlatDamage) {
                const flatDamage = parseInt(row.querySelector('[data-flat-damage-value]').value) || 0;
                characters.push({ name, toHit, ac, hp, flatDamage });
            } else {
                const attacks = damageInputs.map(input => {
                    const attackCount = parseInt(input.closest('.damage-input-group').querySelector('[data-attack-count]').value) || 1;
                    const isSneakAttack = input.closest('.damage-input-group').querySelector('[data-is-sneak-attack]').checked;
                    return {
                        damage: input.value,
                        count: attackCount,
                        isSneakAttack: isSneakAttack
                    };
                });
                characters.push({ name, toHit, ac, hp, attacks });
            }
        });
        return characters;
    }

    function getMonsters() {
        const monsters = [];
        monsterList.querySelectorAll('.monster-row').forEach(row => {
            const name = row.querySelector('[data-name]').value;
            const ac = parseInt(row.querySelector('[data-ac]').value) || 0;
            const hp = parseInt(row.querySelector('[data-hp]').value) || 0;
            const toHit = parseInt(row.querySelector('[data-to-hit-monster]').value) || 0;
            const damageInputs = Array.from(row.querySelectorAll('[data-damage-monster]'));
            
            const attacks = damageInputs.map(input => {
                const attackCount = parseInt(input.closest('.damage-input-group').querySelector('[data-attack-count-monster]').value) || 1;
                return {
                    damage: input.value,
                    count: attackCount,
                };
            });
            monsters.push({ name, ac, hp, toHit, attacks });
        });
        return monsters;
    }

    function createAttackInputGroup(isSneakAttack = false, isMonster = false) {
        const dataPrefix = isMonster ? 'monster-' : '';
        const div = document.createElement('div');
        div.className = 'damage-input-group flex items-center gap-2';
        div.innerHTML = `
            <input type="text" data-damage${isMonster ? '-monster' : ''} placeholder="1d8+5" class="w-24">
            <span class="text-gray-400">x</span>
            <input type="number" data-attack-count${isMonster ? '-monster' : ''} value="1" min="1" class="w-16">
            ${isMonster ? '' : `<div class="flex items-center gap-1">
                <input type="checkbox" data-is-sneak-attack class="h-4 w-4 rounded border-gray-300 bg-gray-600 text-purple-600 focus:ring-purple-500" ${isSneakAttack ? 'checked' : ''}>
                <span class="text-xs text-gray-400">Sneak Attack</span>
            </div>`}
            <button class="remove-attack-btn text-red-500 hover:text-red-300 text-2xl" aria-label="Remove Attack">&times;</button>
        `;
        div.querySelector('.remove-attack-btn').onclick = (e) => {
            e.preventDefault();
            div.remove();
            saveToLocalStorage();
            updateCalculations();
        };
        return div;
    }

    function addCharacterRow(char = {}) {
        const row = document.createElement('div');
        row.className = 'character-row p-4 border border-gray-700 rounded-lg flex flex-wrap gap-4 items-center';
        row.innerHTML = `
            <div class="flex-grow">
                <label class="block text-gray-400 text-sm">Name</label>
                <input type="text" data-name value="${char.name || ''}" class="w-full">
            </div>
            <div class="w-24">
                <label class="block text-gray-400 text-sm">AC</label>
                <input type="number" data-ac value="${char.ac || ''}" class="w-full">
            </div>
            <div class="w-24">
                <label class="block text-gray-400 text-sm">HP</label>
                <input type="number" data-hp value="${char.hp || ''}" class="w-full">
            </div>
            <div class="w-24">
                <label class="block text-gray-400 text-sm">+ to Hit</label>
                <input type="number" data-to-hit value="${char.toHit || ''}" class="w-full">
            </div>
            <div class="flex-grow">
                <div class="flex items-center gap-2">
                    <label class="block text-gray-400 text-sm">Damage</label>
                    <div class="flex items-center gap-1">
                        <input type="checkbox" data-flat-damage class="h-4 w-4 rounded border-gray-300 bg-gray-600 text-purple-600 focus:ring-purple-500" ${char.flatDamage ? 'checked' : ''}>
                        <span class="text-xs text-gray-400">Flat</span>
                    </div>
                    <button class="add-attack-btn text-sm text-purple-400 hover:text-purple-200" style="display: ${char.flatDamage ? 'none' : 'block'};">Add Attack</button>
                </div>
                <div class="damage-inputs-container mt-2" style="display: ${char.flatDamage ? 'none' : 'block'};"></div>
                <input type="number" data-flat-damage-value value="${char.flatDamage || ''}" style="display: ${char.flatDamage ? 'block' : 'none'};" placeholder="e.g., 20" class="w-full">
            </div>
            <button class="remove-character-btn text-red-500 hover:text-red-300 text-2xl">&times;</button>
        `;

        const damageContainer = row.querySelector('.damage-inputs-container');
        if (char.attacks) {
            char.attacks.forEach(attack => {
                const group = createAttackInputGroup(attack.isSneakAttack);
                group.querySelector('[data-damage]').value = attack.damage;
                group.querySelector('[data-attack-count]').value = attack.count;
                damageContainer.appendChild(group);
            });
        }
        
        row.querySelector('.add-attack-btn').onclick = (e) => {
            e.preventDefault();
            damageContainer.appendChild(createAttackInputGroup());
            saveToLocalStorage();
            updateCalculations();
        };

        const flatDamageCheckbox = row.querySelector('[data-flat-damage]');
        const flatDamageValueInput = row.querySelector('[data-flat-damage-value]');
        const addAttackBtn = row.querySelector('.add-attack-btn');
        const damageInputsContainer = row.querySelector('.damage-inputs-container');

        flatDamageCheckbox.onchange = () => {
            if (flatDamageCheckbox.checked) {
                flatDamageValueInput.style.display = 'block';
                addAttackBtn.style.display = 'none';
                damageInputsContainer.style.display = 'none';
            } else {
                flatDamageValueInput.style.display = 'none';
                addAttackBtn.style.display = 'block';
                damageInputsContainer.style.display = 'block';
            }
            saveToLocalStorage();
            updateCalculations();
        };

        row.querySelectorAll('input').forEach(input => {
            input.addEventListener('input', () => {
                saveToLocalStorage();
                updateCalculations();
            });
        });

        row.querySelector('.remove-character-btn').onclick = (e) => {
            e.preventDefault();
            row.remove();
            saveToLocalStorage();
            updateCalculations();
        };

        characterList.appendChild(row);
    }

    function addMonsterRow(monster = {}) {
        const row = document.createElement('div');
        row.className = 'monster-row p-4 border border-gray-700 rounded-lg flex flex-wrap gap-4 items-center';
        row.innerHTML = `
            <div class="flex-grow">
                <label class="block text-gray-400 text-sm">Monster Name</label>
                <input type="text" data-name value="${monster.name || ''}" class="w-full">
            </div>
            <div class="w-24">
                <label class="block text-gray-400 text-sm">AC</label>
                <input type="number" data-ac value="${monster.ac || ''}" class="w-full">
            </div>
            <div class="w-24">
                <label class="block text-gray-400 text-sm">HP</label>
                <input type="number" data-hp value="${monster.hp || ''}" class="w-full">
            </div>
            <div class="w-24">
                <label class="block text-gray-400 text-sm">+ to Hit</label>
                <input type="number" data-to-hit-monster value="${monster.toHit || ''}" class="w-full">
            </div>
            <div class="flex-grow">
                <div class="flex items-center gap-2">
                    <label class="block text-gray-400 text-sm">Damage</label>
                    <button class="add-monster-attack-btn text-sm text-purple-400 hover:text-purple-200">Add Attack</button>
                </div>
                <div class="damage-inputs-container-monster mt-2"></div>
            </div>
            <button class="remove-monster-btn text-red-500 hover:text-red-300 text-2xl">&times;</button>
        `;

        const damageContainer = row.querySelector('.damage-inputs-container-monster');
        if (monster.attacks) {
            monster.attacks.forEach(attack => {
                const group = createAttackInputGroup(false, true);
                group.querySelector('[data-damage-monster]').value = attack.damage;
                group.querySelector('[data-attack-count-monster]').value = attack.count;
                damageContainer.appendChild(group);
            });
        }

        row.querySelector('.add-monster-attack-btn').onclick = (e) => {
            e.preventDefault();
            damageContainer.appendChild(createAttackInputGroup(false, true));
            saveToLocalStorage();
            updateCalculations();
        };
        
        row.querySelectorAll('input').forEach(input => {
            input.addEventListener('input', () => {
                saveToLocalStorage();
                updateCalculations();
            });
        });
        
        row.querySelector('.remove-monster-btn').onclick = (e) => {
            e.preventDefault();
            row.remove();
            saveToLocalStorage();
            updateCalculations();
        };

        monsterList.appendChild(row);
    }

    document.getElementById('add-character-btn').onclick = () => addCharacterRow();
    document.getElementById('add-monster-btn').onclick = () => addMonsterRow();
    document.getElementById('generate-monster-btn').onclick = () => generateMonster();

    // Initial setup
    loadFromLocalStorage();
</script>

</body>
</html>
